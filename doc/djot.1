.\" Automatically generated by Pandoc 3.1.11.1
.\"
.TH "DJOT" "1" "" "djot 0.3.1" ""
.SH NAME
djot \[en] converts djot markup.
.SH SYNOPSIS
djot options [file..]
.SH DESCRIPTION
djot is a command\-line parser for \c
.UR https://djot.net
djot markup
.UE \c
\&.
It can produce
.IP \[bu] 2
an HTML document (default behavior or \f[CR]\-t html\f[R])
.IP \[bu] 2
a stream of annotated tokens with byte offsets (\f[CR]\-t events\f[R])
.IP \[bu] 2
an AST in either human\-readable or JSON form (\f[CR]\-t ast\f[R],
\f[CR]\-t astpretty\f[R]).
.IP \[bu] 2
a djot document (\f[CR]\-t djot\f[R])
.IP \[bu] 2
a pandoc AST serialized to JSON (\f[CR]\-t pandoc\f[R]), which can be
read by pandoc (version >= 3) and converted to many other formats
.PP
It can also read a JSON\-serialized djot AST (\f[CR]\-f ast\f[R]) or a
pandoc AST serialized to JSON (\f[CR]\-f pandoc\f[R]), allowing
conversion from many other formats.
.PP
Finally, it can apply \f[I]filters\f[R] that modify the parsed AST
between the parsing and rendering steps.
This is the primary way in which djot syntax can be customized.
.SH OPTIONS
.TP
\f[CR]\-\-to,\-t\f[R] \f[I]FORMAT\f[R]
Specify format to convert to.
Valid values are \f[CR]html\f[R] (the default), \f[CR]ast\f[R]
(JSON\-formatted AST), \f[CR]astpretty\f[R] (human\-readable AST),
\f[CR]events\f[R] (JSON array of events produced by the tokenizer),
\f[CR]djot\f[R] (djot markup), or \f[CR]pandoc\f[R] (JSON serialized
pandoc AST).
.TP
\f[CR]\-\-from,\-f\f[R] \f[I]FORMAT\f[R]
Specify format to convert from.
Valid values are \f[CR]djot\f[R] (the default), \f[CR]ast\f[R]
(JSON\-formatted AST), and \f[CR]pandoc\f[R] (JSON serialized pandoc
AST).
.TP
\f[CR]\-\-filter\f[R] \f[I]FILE\f[R]
Read a filter from \f[I]FILE\f[R] and apply it to the parsed AST prior
to rendering.
This option may be used multiple times; the filters will be applied in
the order specified on the command line.
See FILTERS below for details.
.TP
\f[CR]\-\-compact\f[R]
Use compact JSON for the AST, with no extra spacing for readbility.
.TP
\f[CR]\-\-width,\-w\f[R] \f[I]NUMBER\f[R]
Text width to which to wrap output of \f[CR]\-t djot\f[R].
If \f[I]NUMBER\f[R] is 0, no wrapping will be done, and line breaks in
the input will be preserved in the output.
If it is \-1, no wrapping will be done, and line breaks in the input
will be treated as spaces.
.TP
\f[CR]\-\-sourcepos,\-p\f[R]
Include information about the start and end positions of elements in the
HTML and AST.
Source positions include the line number, column number (counting
UTF\-16 code units, which might not accord with visible columns), and
character offset in the entire document (again, in UTF\-16 code units).
.TP
\f[CR]\-\-time\f[R]
Print timings for parsing, filtering, and rendering to stderr.
.TP
\f[CR]\-\-quiet\f[R]
Suppress warnings.
.TP
\f[CR]\-\-version\f[R]
Print version
.TP
\f[CR]\-\-help,\-h\f[R]
Print this message.
.SH FILTERS
Filters are JavaScript programs that modify the parsed document prior to
rendering.
Here is an example of a filter that capitalizes all the content text in
a document:
.IP
.EX
// This filter capitalizes regular text, leaving code and URLs unaffected
return {
  str: (el) => {
    el.text = el.text.toUpperCase();
  }
}
.EE
.PP
Save this as \f[CR]caps.js\f[R] use tell djot to use it using
.IP
.EX
djot \-\-filter caps input.js
.EE
.PP
Note: never run a filter from a source you don\[cq]t trust, without
inspecting the code carefully.
Filters are programs, and like any programs they can do bad things on
your system.
.PP
Here\[cq]s a filter that prints a list of all the URLs you link to in a
document.
This filter doesn\[cq]t alter the document at all; it just prints the
list to stderr.
.IP
.EX
return {
  link: (el) => {
    process.stderr.write(el.destination + \[dq]\[rs]n\[dq])
  }
}
.EE
.PP
A filter walks the document\[cq]s abstract syntax tree, applying
functions to like\-tagged nodes, so you will want to get familiar with
how djot\[cq]s AST is designed.
The easiest way to do this is to use \f[CR]djot \-\-ast\f[R] or
\f[CR]djot \-\-astpretty\f[R].
.PP
By default filters do a bottom\-up traversal; that is, the filter for a
node is run after its children have been processed.
It is possible to do a top\-down travel, though, and even to run
separate actions on entering a node (before processing the children) and
on exiting (after processing the children).
To do this, associate the node\[cq]s tag with a table containing
\f[CR]enter\f[R] and/or \f[CR]exit\f[R] functions.
The \f[CR]enter\f[R] function is run when we traverse \f[I]into\f[R] the
node, before we traverse its children, and the \f[CR]exit\f[R] function
is run after we have traversed the node\[cq]s children.
For a top\-down traversal, you\[cq]d just use the \f[CR]enter\f[R]
functions.
If the tag is associated directly with a function, as in the first
example above, it is treated as an \[ga]exit\[cq] function.
.PP
The following filter will capitalize text that is nested inside
emphasis, but not other text:
.IP
.EX
// This filter capitalizes the contents of emph
// nodes instead of italicizing them.
let capitalize = 0;
return {
   emph: {
     enter: (e) => {
       capitalize = capitalize + 1;
     },
     exit: (e) => {
       capitalize = capitalize \- 1;
       e.tag = \[dq]span\[dq];
     },
   },
   str: (e) => {
     if (capitalize > 0) {
       e.text = e.text.toUpperCase();
      }
   }
}
.EE
.PP
Here is a simple filter that changes letter enumerated lists to
roman\-numbered:
.IP
.EX
// Changes letter\-enumerated lists to roman\-numbered
return {
  list: (e) => {
    if (e.style === \[aq]a.\[aq]) {
      e.style = \[aq]i.\[aq];
    } else if (e.style === \[aq]A.\[aq]) {
      e.style = \[aq]I.\[aq];
    }
  }
}
.EE
.PP
A single filter may return a table with multiple tables, which will be
applied sequentially:
.IP
.EX
// This filter includes two sub\-filters, run in sequence
return [
  { // first filter changes (TM) to trademark symbol
    str: (e) => {
      e.text = e.text.replace(/\[rs]\[rs](TM\[rs]\[rs])/, \[dq]â„¢\[dq]);
    }
  },
  { // second filter changes \[aq][]\[aq] to \[aq]()\[aq] in text
    str: (e) => {
      e.text = e.text.replace(/\[rs]\[rs](/,\[dq][\[dq]).replace(/\[rs]\[rs])/,\[dq]]\[dq]);
    }
  }
]
.EE
.PP
The filters we\[cq]ve looked at so far modify nodes in place by changing
one of their properties (\f[CR]text\f[R]).
Sometimes we\[cq]ll want to replace a node with a different kind of
node, or with several nodes, or to delete a node.
In these cases we can end the filter function with a \f[CR]return\f[R].
If a single AST node is returned, it will replace the element the filter
is processing.
If an array of AST nodes is returned, they will be spliced in to replace
the element.
If an empty array is returned, the element will be deleted.
.IP
.EX
// This filter replaces certain Symb nodes with
// formatted text.
const substitutions = {
  mycorp: [ { tag: \[dq]str\[dq], text: \[dq]My Corp\[dq] },
            { tag: \[dq]superscript\[dq],
              [ { tag: \[dq]str\[dq], text: \[dq](TM)\[dq] } ] } ],
  myloc: { tag: \[dq]str\[dq], text: \[dq]Coyote, NM\[dq] }
  };
return {
  symb: (e) => {
    const found = substitutions[e.alias];
    if (found) {
      return found;
    }
  }
}
.EE
.IP
.EX
// This filter replaces all Image nodes with their descriptions.
return {
  image: (e) => {
    return e.children;
  }
}
.EE
.PP
It is possible to inhibit traversal into the children of a node, by
having the \f[CR]enter\f[R] function return an object with the property
\f[CR]stop\f[R].
The contents of \f[CR]stop\f[R] will be used as the regular return
value.
This can be used, for example, to prevent the contents of a footnote
from being processed:
.IP
.EX
return {
 footnote: {
   enter: (e) => {
     return {stop: [e]};
    }
  }
}
.EE
.SH AUTHORS
John MacFarlane (\c
.MT jgm@berkeley.edu
.ME \c
).
